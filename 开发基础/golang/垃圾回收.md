#### 标记清除

**用户程序在垃圾收集的过程不能执行,需要暂停程序(Stop the world, STW)**

###### 标记阶段

- 从根对象出发,遍历对象的所有子对象
- 查找并标记堆中所有存活的对象(根节点可达)

###### 清除阶段

- 收集器依次遍历堆中的所有对象
- 释放没有被标记的对象
- 将新的空闲内存以链表结构串联,方便内存分配器使用



#### 三色标记法

**为了缩短标记清楚法带来的长时间STW, 多数现代的追踪式垃圾收集器都会实现三色标记法的变种,用来缩短STW的时间,三色标记法本身无法并发或者增量执行,仍然需要STW**

###### 三色对象

- 白色对象: 潜在的垃圾,其内存可能会被垃圾收集器回收
- 黑色对象: 活跃的对象,包括不存在任何引用外部指针的对象以及从根对象可达的对象
- 灰色对象: 活跃的对象,因为存在指向白色对象的外部指针,垃圾收集器会扫描这些对象的子对象

###### 标记阶段

最初程序中不存在任何黑色对象,垃圾收集器会将根对象标记为灰色,垃圾收集器只会从灰色对象集合中取出对象开始扫描,当灰色集合中不存在任何对象时,标记阶段结束

- 从灰色对象集合中选择一个对象,并标记为黑色
- 将黑色对象指向的所有对象标记为灰色,保证该对象和被其引用的对象不会被回收
- 重复以上两个步骤,直到对象图中不存在灰色对象

###### 回收阶段

- 当标记阶段结束后,堆中只存在黑色和白色对象
- 回收白色的对象



###### 屏障技术

**内存屏障是一种屏障指令,目前多数的处理器会乱序执行指令以优化性能,内存膨胀能够保证在屏障前的操作一定优先于屏障后的操作**

- 读屏障: 在读操作中加入代码片段,性能影响较大
- 写屏障: 在写操作中加入代码片段
  - 插入写屏障
  - 删除写屏障
  - 混合写屏障

###### 三色不变性

**想要在并发或者增量的标记算法中保证正确性,必须遵循一下两种三色不变性中的一种**

- 强三色不变性: 黑色对象不会指向白色对象,只会指向灰色对象或黑色对象
- 弱三色不变性: 黑色对象指向的白色对象,必须包含一条从灰色对象经过多个白色对象的可达路径

