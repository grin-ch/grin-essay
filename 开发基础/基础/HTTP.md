### HTTP(HyperText Transfer Protocol):超文本传输协议

- `HTTP` 是一个`双向协议`

  数据从一端到另一端的过程中,允许中间有`中转或接力`,只需要中间人遵从HTTP,不打扰基本的数据传输,就可以添加任意额外的东西

- **超文本**(HyperText): 超越了普通文本的文本,可以是文字,图片,视频等的混合体,还有`超链接`,能从一个超文本跳转到另一个超文本.`HTML`就是一种超文本

- [**HTTP状态码**](./http状态码.md): 用来描述HTTP请求的状态

- **HTTP header**:用key-value的方式携带本次传输的一些请求标识,常见字段:

  - `Host`: 客户端发送请求时,用来指定服务器的域名
  - `Content-Length`: 服务器返回数据时,会携带`Content-Length`字段,用来表明本次响应的数据长度
  - `Connection`:最常用于客户端要求服务器使用`TCP`持久连接,以便请求复用(如:Connection:Keep-Alive)
  - `Content-Type`: 用于服务器响应时,描述本次数据的格式(如:`Content-Type:text/html;charset=utf8`这个类型表明,发送的是html格式,utf-8编码的数据)

  - `Accept`: 客户端请求时,可以使用Accept字段声明自己可以接收哪些数据格式(如:Accept:\*/\*,表明可以接受任意格式的数据)
  - `Content-Encoding`:描述数据压缩的方法,服务器返回的数据用了什么压缩格式
  - `Accept-Encoding`: 客户端用来说明自己可以接收哪些压缩方式

- **[Method](./HTTP-Method.md)**: HTTP请求的方法,参考RESTFul规范

- **HTTP特点**: 

  - `简单`:`HTTP`最基本的报文格式就是`header+body`,头部信息也是`key-value`简单的文本形式,易于理解
  - `灵活`和`易于扩展`: `HTTP`里的各类请求方法,URI/URL,状态码,头部字段等,每个部分都允许开发人员`自定义`和`扩充`,同时,因为HTTP是工作在应用层的,它的下层可以任意改变,`HTTPS`也就是在`HTTP`和`TCP`之间增加了`SSL/TLS`安全传输层,`HTTP/3`把`TCP`换成了基于`UDP`的`QUIC`
  - `应用广泛`和`跨平台`: `HTTP`天然具有`跨平台`性,它的应用范围相当广泛,台式机到浏览器到各类APP都有它的身影
  - `无状态`: 服务器不需要记忆HTTP的状态,所zhez以不需要额外的资源记录状态信息,这可以减轻服务器的负担,坏处是,这个特点在一些有关联性的操作上会比较麻烦,例如登入->修改/信息/密码等,这些需要知道用户的信息才能进行.服务器是不知道身份信息的,每次这样的操作都要验证一遍身份信息,显然并不优雅.解决方案有很多,简单的如`Cookie`技术,`Cookie`通过在请求和响应报文中写入Cookie信息来控制用户状态
  - `明文传输`: 明文传输让数据在传输过程是方便阅读的,信息内容毫无隐私,容易暴露敏感信息
  - `不安全`: 
    - 通信使用明文,不加密,容易被**窃听**.
    - 不验证通信方的身份,可能遭遇**伪装**.
    - 无法证明报文的完整性,有可能遭到**篡改**.

- **HTTP性能**: 

  HTTP基于`TCP/IP`协议,并且使用了`请求`和`响应`的通信模式

  - `长连接`:HTTP/1.0中,每次请求都要经过三次握手(`TCP`),并且是串行请求,有非常多的建立和断开,开销很大.

    HTTP/1.1提出了`长连接`的通信方式,也叫持久连接,只要任意一端没有明确提出断开连接,则保持`TCP`连接状态(减少了建立和断开的开销)

  - `管道网络传输`(pipeline):HTTP/1.1提出了长连接,这使得管道网络传输成为可能:在同一个`TCP`连接中发送多个请求,并且后续的请求不需要等待先前请求的响应就能发送,减少了整体响应的时长.`HTTP/1.0`时,后续请求需要等待先前请求的响应,这会造成`队头阻塞`

- **HTTPS**: `HTTPS`相比`HTTP`,多了`SSL/TLS`协议,但是解决了`窃听`,`篡改`,`伪装`三个安全问题

  `SSL/TLS`: SSL和TLS是同一个东西,`SSL`(Secure Sockets Layer)中文叫`安全套接层`,它是90年代中期由网景公司设计,到1999年,SSL因为应用广泛,成为了互联网的事实标准,IETF就把SSL标准化.名称改为了`TLS `(Tranport Layer Security)中文叫`传输层安全协议`.

  - `信息加密`: `混合加密`的方式实现信息的`机密性`,解决了窃听风险

    - `混合加密`:HTTPS采用对称加密和非对称加密结合的混合加密方式

      在通信建立前采用非对称加密的方式交换会话密钥

      在通信过程全部采用对称加密的`会话密钥`的方式加密明文数据

  - `校验机制`: `摘要算法`的方式实现信息的`完整性`,解决了篡改风险

    - `摘要算法`: 客户端在发送明文之前,算出明文的`指纹`,发送的时候把指纹和明文一同加密,然后发给服务器,服务器解密之后验算一遍,指纹一致则数据没被篡改

  - `身份证书`: 将服务器公钥放入`数字证书`中,解决了冒充风险

    - 客户端向服务端索取`公钥`,然后用公钥加密数据,服务端收到数据后,用自己的`私钥`解密,但是如何保证`公钥`不被篡改(中间人攻击)?

    - `数字证书认证机构`(**CA**): 将公钥放在**数字证书**中,只要证书是可信的,公钥就是可信的.

      数字证书通常包括: `公钥`.`持有者`的信息,`CA`的信息,CA对这份文件的`数字签名`和使用的`算法`,证书`有效期`,还有一些其他信息

      (CA有自己的私钥和公钥,公钥已事先置入浏览器和操作系统中)

      1. 服务器将公钥注册到CA中
      2. CA用自己的私钥将服务器的公钥数字签名,并且颁发`数字证书`
      3. 客户端拿到服务器的数字证书后(从服务器获取),使用CA的公钥确认服务器公钥的真实性
      4. 客户端从`数字证书`中获取到服务器公钥后,用服务器公钥加密报文,发送到服务器
      5. 服务器用自己的`私钥`对报文进行解密

- `SSL/TLS`的建立连接的流程:(以下是SSL/TLS 1.2版本,1.3有改变,并且根据不同的密钥交换算法,过程也有一些差异,常用的是RAS,ECDHE,以下是RSA)

  1. ClientHello: 客户端向服务器发起连接请求,主要发送包括以下信息

     - 客户端的`SSL/TLS`协议版本,如`SSL/TLS1.2`
     - 客户端产生的随机数(Client Random),后续用于生产`会话密钥`
     - 客户端支持的密码套件列表,如`RSA`加密算法

  2. ServerHello: 服务端收到请求后,发出响应,响应包括以下信息

     - 确认`SSL/TLS`协议版本,如果浏览器不支持,则关闭加密通信
     - 服务器产生的随机数(Server Random),后续用于生产`会话密钥`
     - 确认客户端的密码套件列表
     - 服务器的数字证书

  3. 客户端回应: 客户端收到响应之后,用浏览器或操作系统中的`CA公钥`确认服务端的数字证书的真实性,确认后,从数字证书中获取服务器`公钥`,然后用公钥加密报文,包括以下信息

     - 一个随机数(pre-master key)
     - 加密通信算法改变通知,表示随后的通信都将用`会话密钥`加密通信
     - 客户端握手结束通知,表示客户端握手阶段已经接收,并且将之前的所有内容发送的数据做个摘要,一起发给服务端用于校验

     **pre-master key是第三个随机数,这样服务器和客户端都同时拥有三个随机数,接着就用双方协商的加密算法,`各自生成`本次通信的`会话密钥`**

  4. 服务器回应: 服务端收到回应之后,计算出本次的`会话密钥`,并且发送最后的信息:

     - 加密通信算法改变通知,表示随后的通信都将用`会话密钥`加密通信
     - 服务器握手接收通知,表示服务器握手阶段结束,并且将之前的所有内容发送的数据做个摘要,一起发给客户端用于校验

  **整个`SSL/TLS`的握手阶段到此结束,双方接下来完全使用普通的`HTTP`通信,但是会使用`会话密钥`来加密报文(对称加密),简单的来说,就是使用非对称加密的方式交换对称加密需要的密钥.之后的报文用密钥进行对称加密**

  

  
